# -*- coding: utf-8 -*-
"""VCS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LcYJEQ97G9PS6hGlFuEg5eKIex7cRQtX

# Libraries and functions
"""

pip install visualkeras

import tensorflow as tf
from tensorflow import keras
from keras import layers
import matplotlib.pyplot as plt
import numpy as np
from skimage import metrics
from sklearn.datasets import fetch_lfw_people
from sklearn.model_selection import train_test_split
import cv2
from keras.layers import Input, Conv2D, Add, BatchNormalization, Activation, ReLU
from keras.models import Model
import keras.backend as K
from keras.optimizers import Adam
from keras.applications import ResNet50
import visualkeras
import cv2
from google.colab.patches import cv2_imshow

def PSNR(y_true, y_pred):
    max_pixel = 255
    return 20 * np.log10(max_pixel / np.sqrt(np.mean((y_true - y_pred)**2)))
    
def psnr(y_true, y_pred):
    return tf.image.psnr(y_true, y_pred, 255)

def SSIM(x, y):
    return metrics.structural_similarity(x, y, sigma=1.5,use_sample_covariance= False, gaussian_weights=True, multichannel=True, data_range=255)

def ssim(y_true, y_pred):
    return tf.image.ssim(y_true, y_pred, 255)

def L1_loss(y_true, y_pred):
    return tf.reduce_mean(tf.abs(y_true - y_pred))

def pixel_loss(y_true, y_pred):
    return tf.reduce_mean((y_true - y_pred) ** 2)

def PSNR_loss(y_true, y_pred):
    return  1/tf.reduce_mean(psnr(y_true, y_pred))

def SSIM_loss(y_true, y_pred):
  return 1 - tf.reduce_mean(tf.image.ssim(y_true, y_pred, 255))

def PSNR_SSIM_loss(y_true, y_pred):
    return SSIM_loss(y_true, y_pred) +  0.5 * PSNR_loss(y_true, y_pred)

def min_max_scaling(inputs):
    min_val = tf.reduce_min(inputs)
    max_val = tf.reduce_max(inputs)
    inputs = (inputs - min_val) / (max_val - min_val)
    return inputs, min_val, max_val

# Plot the results
# create a figure with 2 rows and 5 columns
def plot_images(GT_train, GT_test, blurred_train, blurred_test, pixelated_train, pixelated_test, train_pred_blurred, test_pred_blurred, train_pred_pixelated, test_pred_pixelated):
  fig, axes = plt.subplots(2, 5, figsize=(16, 6))
  
  # set the titles for each subplot
  axes[0, 0].set_title("Original Image", fontsize=14)
  axes[0, 1].set_title("Blurred Image", fontsize=14)
  axes[0, 2].set_title("Reconstructed Blurred", fontsize=14)
  axes[0, 3].set_title("Pixelated Image", fontsize=14)
  axes[0, 4].set_title("Reconstructed Pixelated", fontsize=14)

  # plot the images
  axes[0, 0].imshow(GT_train[7]/255)
  axes[0, 0].axis('off')
  axes[0, 0].text(0.25, -0.1, "PSNR/SSIM", fontsize=14, transform=axes[0,0].transAxes)  
  axes[0, 0].text(-0.15, 0.25, "Training set", rotation=90, fontsize=14, transform=axes[0,0].transAxes)

  axes[0, 1].imshow(blurred_train[7]/255)
  axes[0, 1].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_train[0],blurred_train[0]),2)), str(round(SSIM(GT_train[0],blurred_train[0]),2)) 
  axes[0, 1].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[0,1].transAxes)  

  axes[0, 2].imshow(train_pred_blurred[7]/255)
  axes[0, 2].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_train[0],train_pred_blurred[0]),2)), str(round(SSIM(GT_train[0],train_pred_blurred[0]),2)) 
  axes[0, 2].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[0,2].transAxes)  

  axes[0, 3].imshow(pixelated_train[7]/255)
  axes[0, 3].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_train[0],pixelated_train[0]),2)), str(round(SSIM(GT_train[0],pixelated_train[0]),2)) 
  axes[0, 3].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[0,3].transAxes)  

  axes[0, 4].imshow(train_pred_pixelated[7]/255)
  axes[0, 4].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_train[0],train_pred_pixelated[0]),2)), str(round(SSIM(GT_train[0],train_pred_pixelated[0]),2)) 
  axes[0, 4].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[0,4].transAxes)  

  axes[1, 0].imshow(GT_test[9]/255)
  axes[1, 0].axis('off')
  axes[1, 0].text(0.25, -0.1, "PSNR/SSIM", fontsize=14, transform=axes[1,0].transAxes)  
  axes[1, 0].text(-0.15, 0.3, "Test set", rotation=90, fontsize=14, transform=axes[1,0].transAxes)

  axes[1, 1].imshow(blurred_test[9]/255)
  axes[1, 1].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_test[0],blurred_test[0]),2)), str(round(SSIM(GT_test[0],blurred_test[0]),2)) 
  axes[1, 1].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[1,1].transAxes)  

  axes[1, 2].imshow(test_pred_blurred[9]/255)
  axes[1, 2].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_test[0],test_pred_blurred[0]),2)), str(round(SSIM(GT_test[0],test_pred_blurred[0]),2)) 
  axes[1, 2].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14,  transform=axes[1,2].transAxes)  

  axes[1, 3].imshow(pixelated_test[9]/255)
  axes[1, 3].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_test[0],pixelated_test[0]),2)), str(round(SSIM(GT_test[0],pixelated_test[0]),2)) 
  axes[1, 3].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[1,3].transAxes)  

  axes[1, 4].imshow(test_pred_pixelated[9]/255)
  axes[1, 4].axis('off')
  psnr_value, ssim_value = str(round(PSNR(GT_test[0],test_pred_pixelated[0]),2)), str(round(SSIM(GT_test[0],test_pred_pixelated[0]),2)) 
  axes[1, 4].text(0.25, -0.1, psnr_value +'/' + ssim_value, fontsize=14, transform=axes[1,4].transAxes) 
  
  plt.show()

def plot_loss(history):
  plt.figure(figsize=(10,6))
  plt.plot(history.epoch,history.history['loss'], label='train_loss', linewidth=3)
  plt.plot(history.epoch,history.history['val_loss'],label='val_loss', linewidth=3)
  plt.grid('on'), plt.xlabel('Epoch'), plt.ylabel('Loss')
  plt.legend()
  
def plot_psnr(history):
  plt.figure(figsize=(10,6))
  plt.plot(history.epoch,history.history['psnr'],label='train_psnr', linewidth=3)
  plt.plot(history.epoch,history.history['val_psnr'],label='val_psnr', linewidth=3)
  plt.grid('on'), plt.xlabel('Epoch'), plt.ylabel('PSNR')
  plt.legend()

def plot_ssim(history):
  plt.figure(figsize=(10,6))
  plt.plot(history.epoch,history.history['ssim'],label='train_ssim', linewidth=3)
  plt.plot(history.epoch,history.history['val_ssim'],label='val_ssim', linewidth=3)
  plt.grid('on'), plt.xlabel('Epoch'), plt.ylabel('SSIM')
  plt.legend()

def plot_all_psnr(history1,history2,history3,history4,history5):
  plt.figure(figsize=(10,6))
  plt.plot(history1.epoch,history1.history['psnr'],label='L2', linewidth=3)
  plt.plot(history1.epoch,history1.history['val_psnr'],'--',label='L2_val', linewidth=3)
  plt.plot(history2.epoch,history2.history['psnr'],label='L1', linewidth=3)
  plt.plot(history2.epoch,history2.history['val_psnr'],'--',label='L1_val', linewidth=3)
  plt.plot(history3.epoch,history3.history['psnr'],label='PSNR', linewidth=3)
  plt.plot(history3.epoch,history3.history['val_psnr'],'--',label='PSNR_val', linewidth=3)
  plt.plot(history4.epoch,history4.history['psnr'],label='SSIM', linewidth=3)
  plt.plot(history4.epoch,history4.history['val_psnr'],'--',label='SSIM_val', linewidth=3)
  plt.plot(history5.epoch,history5.history['psnr'],label='PSNR+SSIM', linewidth=3)
  plt.plot(history5.epoch,history5.history['val_psnr'],'--',label='PSNR+SSIM_val', linewidth=3)
  plt.grid('on'), plt.xlabel('Epoch'), plt.ylabel('PSNR')
  plt.legend()

def plot_all_ssim(history1,history2,history3,history4,history5):
  plt.figure(figsize=(10,6))
  plt.plot(history1.epoch,history1.history['ssim'],label='L2', linewidth=3)
  plt.plot(history1.epoch,history1.history['val_ssim'],'--',label='L2_val', linewidth=3)
  plt.plot(history2.epoch,history2.history['ssim'],label='L1', linewidth=3)
  plt.plot(history2.epoch,history2.history['val_ssim'],'--',label='L1_val', linewidth=3)
  plt.plot(history3.epoch,history3.history['ssim'],label='PSNR', linewidth=3)
  plt.plot(history3.epoch,history3.history['val_ssim'],'--',label='PSNR_val', linewidth=3)
  plt.plot(history4.epoch,history4.history['ssim'],label='SSIM', linewidth=3)
  plt.plot(history4.epoch,history4.history['val_ssim'],'--',label='SSIM_val', linewidth=3)
  plt.plot(history5.epoch,history5.history['ssim'],label='PSNR+SSIM', linewidth=3)
  plt.plot(history5.epoch,history5.history['val_ssim'],'--',label='PSNR+SSIM_val', linewidth=3)
  plt.grid('on'), plt.xlabel('Epoch'), plt.ylabel('SSIM')
  plt.legend()

"""# Introduction"""

# Load the dataset
images = fetch_lfw_people(resize=1.2, color=True, funneled=False).images[:2500] 
print("images shape", images.shape)

# Define the target size
target_size = (112, 112)

# Create a new list to store the resized images
tmp = []

# Loop through each image in the training set
for img in images:
    # Resize the image using OpenCV
    img_resized = cv2.resize(img, target_size)
    # Add the resized image to the new list
    tmp.append(img_resized)

# Convert the list of resized images to a numpy array
images = np.array(tmp)

# Creating the pixelated version of the images
tmp = []
scale = 6
for img in images:
    # Downscale the image
    img_downscaled = cv2.resize(img, (img.shape[1] // scale, img.shape[0] // scale), interpolation=cv2.INTER_NEAREST)
    # Upscale the downscaled image back to the original size
    img_pixelated = cv2.resize(img_downscaled, (img.shape[1], img.shape[0]),interpolation=cv2.INTER_NEAREST)
    tmp.append(img_pixelated)
images_pixelated = np.array(tmp)

# Creating the blurred version of the images
tmp = []
kernel_size = (15,15)
for img in images:
    tmp.append(cv2.GaussianBlur(img, kernel_size, 4))
images_blurred = np.array(tmp)

# Split in training ad test data
X_train_pixelated, X_test_pixelated, y_train, y_test = train_test_split(images_pixelated,images, test_size=0.20, random_state=42)
X_train_blurred, X_test_blurred = train_test_split(images_blurred, test_size=0.20, random_state=42)

# Save some RAM
images = None 
images_pixelated = None
images_blurred = None
tmp = None

print(y_train.shape)
print(y_test.shape)
print(X_train_pixelated.shape)
print(X_test_pixelated.shape)
print(X_train_blurred.shape)
print(X_test_blurred.shape)

n_rows = 1
n_cols = 5
plt.figure(figsize=(n_cols * 1.8, n_rows * 2))

for col in range(n_cols):
    index = col
    p = plt.subplot(n_rows, n_cols, index + 1)
    plt.imshow(y_train[index] / 255, cmap="binary", interpolation="nearest")
    plt.text(0.1, -0.2, "PSNR/SSIM", fontsize=12, transform=p.transAxes)  
    plt.axis("off")

plt.show()

plt.figure(figsize=(n_cols * 1.8, n_rows * 2))

for col in range(n_cols):
    index = col
    p = plt.subplot(n_rows, n_cols, index + 1)
    plt.imshow(X_train_pixelated[index] / 255, cmap="binary", interpolation="nearest")
    psnr_value, ssim_value = str(round(PSNR(y_train[index],X_train_pixelated[index]),2)), str(round(SSIM(y_train[index],X_train_pixelated[index]),2)) 
    plt.text(0.1, -0.2,  psnr_value +'/' + ssim_value, fontsize=12, transform=p.transAxes)  
    plt.axis("off")

plt.show()

plt.figure(figsize=(n_cols * 1.8, n_rows * 2))

for col in range(n_cols):
    index = col
    p = plt.subplot(n_rows, n_cols, index + 1)
    plt.imshow(X_train_blurred[index] / 255, cmap="binary", interpolation="nearest")        
    psnr_value, ssim_value = str(round(PSNR(y_train[index],X_train_blurred[index]),2)), str(round(SSIM(y_train[index],X_train_blurred[index]),2)) 
    plt.text(0.1, -0.2,  psnr_value +'/' + ssim_value, fontsize=12, transform=p.transAxes)   
    plt.axis("off")

plt.show()

"""# Models"""

optimizer = Adam(learning_rate=0.0001)
callbacks = [keras.callbacks.EarlyStopping(patience=5)]

# Residual Autoencoder architechture

# Residual blocks
def residual_block(input_tensor, filters, strides=1):
    x = layers.Conv2D(filters, (3, 3), strides=strides, padding='same')(input_tensor)
    x = layers.BatchNormalization()(x)
    x = Activation('relu')(x)
    
    x = layers.Conv2D(filters, (3, 3), strides=strides, padding='same')(x)
    x = layers.BatchNormalization()(x)
    x = layers.add([input_tensor,x])
    
    return x

def build_model1():
  inputs = layers.Input(shape=(112, 112, 3))
    
  # Preprocess the input
  x, min_val, max_val = min_max_scaling(x)

  x = layers.Conv2D(64, (9, 9), padding='same')(inputs)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(64, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(128, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(256, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  for _ in range(3):
    x = residual_block(x, 256)

  x = layers.Conv2DTranspose(256, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2DTranspose(128, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2DTranspose(64, (4, 4), strides=2, padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2DTranspose(3, (9, 9), activation='sigmoid', padding='same')(x) 

  # Output in original scale
  x = x * (max_val - min_val) + min_val
    
  model = tf.keras.Model(inputs, x)
  return model

# Simple Convolutional Neural Network
def build_model2():

  # Define the input shape for the image
  inputs = layers.Input(shape=(112, 112, 3))

  x, min_val, max_val = min_max_scaling(inputs)

  # Define the model

  x = layers.Conv2D(128, (9, 9), padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(128, (4, 4), padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(128, (4, 4), padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)

  x = layers.Conv2D(128, (4, 4), padding='same')(x)
  x = layers.BatchNormalization()(x)
  x = Activation('relu')(x)
  
  # Add the final output layer with sigmoid activation function
  x = layers.Conv2D(3, (4, 4), activation='sigmoid', padding='same')(x)

  # Output in original scale
  x = x * (max_val - min_val) + min_val  
 
  model = tf.keras.Model(inputs, x)
  return model

# SRResNet repurposed for image reconstruction

# Residual blocks
def residual_block_gen():
  model=tf.keras.Sequential([
    tf.keras.layers.Conv2D(64,3,strides=1,padding='same'),
    tf.keras.layers.BatchNormalization(),
    tf.keras.layers.PReLU(),
    tf.keras.layers.Conv2D(64,3,strides=1,padding='same'),
    tf.keras.layers.BatchNormalization(),
  ])
  return model

def build_model3():
  inputs =tf.keras.layers.Input(shape=(112,112,3))

  x, min_val, max_val = min_max_scaling(inputs)

  input_conv=tf.keras.layers.Conv2D(64,9,padding='same')(x)
  input_conv=tf.keras.layers.PReLU()(input_conv)

  Res=input_conv
  for _ in range(5):
    res_output=residual_block_gen()(Res)
    Res=tf.keras.layers.Add()([Res,res_output])

  Res=tf.keras.layers.Conv2D(64,9,padding='same')(Res)
  Res=tf.keras.layers.BatchNormalization()(Res)

  Res=tf.keras.layers.Add()([Res,input_conv])

  output=tf.keras.layers.Conv2D(3,9,activation='sigmoid',padding='same')(Res)

  # Output in original scale
  output = output * (max_val - min_val) + min_val  

  Resnet=tf.keras.models.Model(inputs,output)
  return Resnet

# Discriminator and generator Losses
cross_entropy = tf.keras.losses.BinaryCrossentropy()
def discriminator_loss(real_output, fake_output):
    real_loss = cross_entropy(tf.ones_like(real_output), real_output)
    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)
    total_loss = real_loss + fake_loss
    return total_loss
def generator_loss(fake_output):
    return cross_entropy(tf.ones_like(fake_output), fake_output)

# Discriminator architecture

def residual_block_disc(ch, st):
  model=tf.keras.Sequential([
    tf.keras.layers.Conv2D(ch,3,strides=st,padding='same'),
    tf.keras.layers.BatchNormalization(),
    tf.keras.layers.LeakyReLU(),
  ])
  return model
def build_discriminator():
  input=tf.keras.layers.Input(shape=(112,112,3))

  input_conv=tf.keras.layers.Conv2D(64,3,padding='same')(input)
  input_conv=tf.keras.layers.LeakyReLU()(input_conv)

  channel_nums=[64,128,128,256,256,512,512]
  stride_sizes=[2,1,2,1,2,1,2]

  disc=input_conv

  for x in range(7):
    disc=residual_block_disc(ch=channel_nums[x],st=stride_sizes[x])(disc)
  
  disc=tf.keras.layers.Flatten()(disc)

  disc=tf.keras.layers.Dense(1024)(disc)
  disc=tf.keras.layers.LeakyReLU()(disc)

  disc_output=tf.keras.layers.Dense(1,activation='sigmoid')(disc)
  disc = tf.keras.models.Model(input,disc_output)
  
  return disc

"""## Models plots

### Residual Autoencoder
"""

build_model1().summary()

tf.keras.utils.plot_model(build_model1(),show_shapes=True)

# Don't run it if the models have min_max scaling active. Remove the scaling momentarely and connect 'input' instead of 'x' to run this cell
visualkeras.layered_view(build_model1(), to_file='output.png',legend=True)
image = cv2.imread("output.png")
cv2_imshow(image)

"""### CNN"""

build_model2().summary()

tf.keras.utils.plot_model(build_model2(),show_shapes=True)

# Don't run it if the models have min_max scaling active. Remove the scaling momentarely and connect 'input' instead of 'x' to run this cell
#visualkeras.layered_view(build_model2(), to_file='output.png',legend=True)
#image = cv2.imread("output.png")
#cv2_imshow(image)

"""### ResNet"""

build_model3().summary()

tf.keras.utils.plot_model(build_model3(),show_shapes=True)

# Don't run it if the models have min_max scaling active. Remove the scaling momentarely and connect 'input' instead of 'x' to run this cell
#visualkeras.layered_view(build_model3(), to_file='output.png',legend=True)
#image = cv2.imread("output.png")
#cv2_imshow(image)

"""### Discriminator"""

build_discriminator().summary()

tf.keras.utils.plot_model(build_discriminator(),show_shapes=True)

visualkeras.layered_view(build_discriminator(), to_file='output.png',legend=True)
image = cv2.imread("output.png")
cv2_imshow(image)

"""# Simple CNN

## MSE Loss (L2)
"""

model_pixelated = build_model2()
model_pixelated.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
# Train the model
history_pixelated1 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated1 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated1 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model2()
model_blurred.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
history_blurred1 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred1 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred1 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## MAE Loss (L1)"""

model_pixelated = build_model2()
model_pixelated.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_pixelated2 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated2 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated2 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model2()
model_blurred.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_blurred2 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred2 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred2 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR Loss"""

model_pixelated = build_model2()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_pixelated3 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated3 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated3 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model2()
model_blurred.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_blurred3 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred3 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred3 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## SSIM Loss"""

model_pixelated = build_model2()
model_pixelated.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_pixelated4 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated4 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated4 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model2()
model_blurred.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_blurred4 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred4 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred4 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR + SSIM Loss"""

model_pixelated = build_model2()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_pixelated5 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated5 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated5 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model2()
model_blurred.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_blurred5 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred5 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred5 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## Plots"""

# Pixel Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred1, test_pred_blurred1, train_pred_pixelated1, test_pred_pixelated1)

# L1 Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred2, test_pred_blurred2, train_pred_pixelated2, test_pred_pixelated2)

# PSNR Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred3, test_pred_blurred3, train_pred_pixelated3, test_pred_pixelated3)

# SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred4, test_pred_blurred4, train_pred_pixelated4, test_pred_pixelated4)

# PSNR + SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred5, test_pred_blurred5, train_pred_pixelated5, test_pred_pixelated5)

"""## Losses Plots"""

plot_loss(history_pixelated1)
plot_psnr(history_pixelated1)
plot_ssim(history_pixelated1)

plot_loss(history_blurred1)
plot_psnr(history_blurred1)
plot_ssim(history_blurred1)

plot_loss(history_pixelated2)
plot_psnr(history_pixelated2)
plot_ssim(history_pixelated2)

plot_loss(history_blurred2)
plot_psnr(history_blurred2)
plot_ssim(history_blurred2)

plot_loss(history_pixelated3)
plot_psnr(history_pixelated3)
plot_ssim(history_pixelated3)

plot_loss(history_blurred3)
plot_psnr(history_blurred3)
plot_ssim(history_blurred3)

plot_loss(history_pixelated4)
plot_psnr(history_pixelated4)
plot_ssim(history_pixelated4)

plot_loss(history_blurred4)
plot_psnr(history_blurred4)
plot_ssim(history_blurred4)

plot_loss(history_pixelated5)
plot_psnr(history_pixelated5)
plot_ssim(history_pixelated5)

plot_loss(history_blurred5)
plot_psnr(history_blurred5)
plot_ssim(history_blurred5)

plot_all_psnr(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)
plot_all_ssim(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)

plot_all_psnr(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)
plot_all_ssim(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)

"""# Residual Network

## MSE Loss (L2)
"""

model_pixelated = build_model3()
model_pixelated.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
# Train the model
history_pixelated1 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated1 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated1 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model3()
model_blurred.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
history_blurred1 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred1 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred1 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## MAE Loss (L1)"""

model_pixelated = build_model3()
model_pixelated.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_pixelated2 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated2 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated2 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model3()
model_blurred.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_blurred2 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred2 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred2 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR Loss"""

model_pixelated = build_model3()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_pixelated3 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated3 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated3 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model3()
model_blurred.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_blurred3 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred3 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred3 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## SSIM Loss"""

model_pixelated = build_model3()
model_pixelated.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_pixelated4 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated4 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated4 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model3()
model_blurred.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_blurred4 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred4 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred4 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR + SSIM Loss"""

model_pixelated = build_model3()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_pixelated5 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated5 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated5 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model3()
model_blurred.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_blurred5 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred5 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred5 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## Plots"""

# Pixel Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred1, test_pred_blurred1, train_pred_pixelated1, test_pred_pixelated1)

# L1 Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred2, test_pred_blurred2, train_pred_pixelated2, test_pred_pixelated2)

# PSNR Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred3, test_pred_blurred3, train_pred_pixelated3, test_pred_pixelated3)

# SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred4, test_pred_blurred4, train_pred_pixelated4, test_pred_pixelated4)

# PSNR + SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred5, test_pred_blurred5, train_pred_pixelated5, test_pred_pixelated5)

"""## Losses Plots"""

plot_loss(history_pixelated1)
plot_psnr(history_pixelated1)
plot_ssim(history_pixelated1)

plot_loss(history_blurred1)
plot_psnr(history_blurred1)
plot_ssim(history_blurred1)

plot_loss(history_pixelated2)
plot_psnr(history_pixelated2)
plot_ssim(history_pixelated2)

plot_loss(history_blurred2)
plot_psnr(history_blurred2)
plot_ssim(history_blurred2)

plot_loss(history_pixelated3)
plot_psnr(history_pixelated3)
plot_ssim(history_pixelated3)

plot_loss(history_blurred3)
plot_psnr(history_blurred3)
plot_ssim(history_blurred3)

plot_loss(history_pixelated4)
plot_psnr(history_pixelated4)
plot_ssim(history_pixelated4)

plot_loss(history_blurred4)
plot_psnr(history_blurred4)
plot_ssim(history_blurred4)

plot_loss(history_pixelated5)
plot_psnr(history_pixelated5)
plot_ssim(history_pixelated5)

plot_loss(history_blurred5)
plot_psnr(history_blurred5)
plot_ssim(history_blurred5)

plot_all_psnr(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)
plot_all_ssim(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)

plot_all_psnr(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)
plot_all_ssim(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)

"""# Residual Autoencoder

## MSE Loss (L2)
"""

model_pixelated = build_model1()
model_pixelated.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
# Train the model
history_pixelated1 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated1 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated1 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model1()
model_blurred.compile(optimizer=optimizer, loss=pixel_loss,  metrics=[psnr, ssim])
history_blurred1 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred1 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred1 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## MAE Loss (L1)"""

model_pixelated = build_model1()
model_pixelated.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_pixelated2 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated2 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated2 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model1()
model_blurred.compile(optimizer=optimizer, loss=L1_loss,  metrics=[psnr, ssim])
history_blurred2 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred2 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred2 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR Loss"""

model_pixelated = build_model1()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_pixelated3 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated3 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated3 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model1()
model_blurred.compile(optimizer=optimizer, loss=PSNR_loss,  metrics=[psnr, ssim])
history_blurred3 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred3 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred3 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## SSIM Loss"""

model_pixelated = build_model1()
model_pixelated.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_pixelated4 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated4 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated4 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model1()
model_blurred.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
history_blurred4 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred4 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred4 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## PSNR + SSIM Loss"""

model_pixelated = build_model1()
model_pixelated.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_pixelated5 = model_pixelated.fit(X_train_pixelated, y_train, epochs=20, batch_size=16, validation_data=(X_test_pixelated, y_test), callbacks=callbacks)
# Predict using the model
train_pred_pixelated5 = model_pixelated.predict(X_train_pixelated[:10])
test_pred_pixelated5 = model_pixelated.predict(X_test_pixelated[:10])

model_blurred = build_model1()
model_blurred.compile(optimizer=optimizer, loss=PSNR_SSIM_loss,  metrics=[psnr, ssim])
history_blurred5 = model_blurred.fit(X_train_blurred, y_train, epochs=20, batch_size=16, validation_data=(X_test_blurred, y_test), callbacks=callbacks)
# Predict using the model
train_pred_blurred5 = model_blurred.predict(X_train_blurred[:10])
test_pred_blurred5 = model_blurred.predict(X_test_blurred[:10])

train_scores_blurred = model_blurred.evaluate(X_train_blurred, y_train, verbose=2)
test_scores_blurred = model_blurred.evaluate(X_test_blurred, y_test, verbose=2)

train_scores_pixelated = model_pixelated.evaluate(X_train_pixelated, y_train, verbose=2)
test_scores_pixelated = model_pixelated.evaluate(X_test_pixelated, y_test, verbose=2)

"""## Plots"""

# Pixel Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred1, test_pred_blurred1, train_pred_pixelated1, test_pred_pixelated1)

# L1 Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred2, test_pred_blurred2, train_pred_pixelated2, test_pred_pixelated2)

# PSNR Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred3, test_pred_blurred3, train_pred_pixelated3, test_pred_pixelated3)

# SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred4, test_pred_blurred4, train_pred_pixelated4, test_pred_pixelated4)

# PSNR + SSIM Loss
plot_images(y_train, y_test, X_train_blurred, X_test_blurred, X_train_pixelated, X_test_pixelated, train_pred_blurred5, test_pred_blurred5, train_pred_pixelated5, test_pred_pixelated5)

"""## Losses Plots"""

plot_loss(history_pixelated1)
plot_psnr(history_pixelated1)
plot_ssim(history_pixelated1)

plot_loss(history_blurred1)
plot_psnr(history_blurred1)
plot_ssim(history_blurred1)

plot_loss(history_pixelated2)
plot_psnr(history_pixelated2)
plot_ssim(history_pixelated2)

plot_loss(history_blurred2)
plot_psnr(history_blurred2)
plot_ssim(history_blurred2)

plot_loss(history_pixelated3)
plot_psnr(history_pixelated3)
plot_ssim(history_pixelated3)

plot_loss(history_blurred3)
plot_psnr(history_blurred3)
plot_ssim(history_blurred3)

plot_loss(history_pixelated4)
plot_psnr(history_pixelated4)
plot_ssim(history_pixelated4)

plot_loss(history_blurred4)
plot_psnr(history_blurred4)
plot_ssim(history_blurred4)

plot_loss(history_pixelated5)
plot_psnr(history_pixelated5)
plot_ssim(history_pixelated5)

plot_loss(history_blurred5)
plot_psnr(history_blurred5)
plot_ssim(history_blurred5)

plot_all_psnr(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)
plot_all_ssim(history_pixelated1,history_pixelated2,history_pixelated3,history_pixelated4,history_pixelated5)

plot_all_psnr(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)
plot_all_ssim(history_blurred1,history_blurred2,history_blurred3,history_blurred4,history_blurred5)

"""# GAN"""

# Define the optimizer for both the generator and discriminator
generator_optimizer = optimizer
discriminator_optimizer = optimizer
# Define generator and discriminator models
generator = build_model3()
discriminator= build_discriminator()
# Define the number of epochs and the batch size
num_epochs = 20
batch_size = 16

# Define the training loop
for epoch in range(num_epochs):
    for i in range(0, len(X_train_blurred), batch_size):
        # Get a batch of blurred images and the corresponding original images
        blurred_batch = X_train_blurred[i:i + batch_size]
        original_batch = y_train[i:i + batch_size]

        with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:
          reconstructed = generator(blurred_batch, training=True)
          gen_loss=SSIM_loss(original_batch,reconstructed)

          real_output = discriminator(original_batch, training=True)
          fake_output = discriminator(reconstructed, training=True)
      
          adv_loss_g = generator_loss(fake_output) * 0.001
          gen_loss += adv_loss_g

          disc_loss = discriminator_loss(real_output, fake_output)
      
        gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)
        generator_optimizer.apply_gradients(zip(gradients_of_generator, generator.trainable_variables))

        gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)
        discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))

    # Print the loss values for each epoch
    print("Epoch: {}, Discriminator loss: {}, Generator loss: {}".format(epoch, disc_loss, gen_loss))

# PSNR + SSIM Loss

generator.compile(optimizer=optimizer, loss=SSIM_loss,  metrics=[psnr, ssim])
generator.evaluate(X_train_blurred, y_train, verbose=2)

